<!-- Ten Minute Physics - Matthias Mueller -->

<!DOCTYPE html>
<html>

<head>
	<title>Sand</title>
	<style>
		.button {
		background-color: #606060;
		border: none;
		color: white;
		padding: 15px 32px;
		font-size: 16px;
		margin: 4px 2px;
		cursor: pointer;
	}
	</style>
</head>

<body>

<table style="width:100%">
	<tr>
		<td><button class="button" onclick="setupScene()">Restart</button></td>
	</tr>
	<tr>
		<td>
			<canvas id="myCanvas" style="border:2px solid"></canvas>
		</td>
	</tr>
</table>

<script>

	// drawing -------------------------------------------------------

	var canvas = document.getElementById("myCanvas");
	var c = canvas.getContext("2d");

	canvas.width = window.innerWidth - 20;
	canvas.height = window.innerHeight - 100;

	var simMinWidth = 2.0;
	var cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
	var simWidth = canvas.width / cScale;
	var simHeight = canvas.height / cScale;

	function cX(pos) {
		return pos.x * cScale;
	}

	function cY(pos) {
		return canvas.height - pos.y * cScale;
	}

// vector math -------------------------------------------------------

	function vecCopy(a) {
		return { x : a.x, y : a.y };
	}

	function vecAdd(a, b, scale = 1.0) {
		return { x : a.x + scale * b.x, y : a.y + scale * b.y};
	}

	function vecSub(a, b, scale = 1.0) {
		return { x : a.x - scale * b.x, y : a.y - scale * b.y};
	}

	function vecScale(a, scale) {
		return { x : scale * a.x, y : scale * a.y}
	}

	function vecLength(a) {
		return Math.sqrt(a.x * a.x + a.y * a.y);
	}
	
	function vecDot(a, b) {
		return a.x * b.x + a.y * b.y;
	}

	// scene -------------------------------------------------------

	var gravity = { x: 0.0, y: -10.0};
	var numSteps = 10;
	var timeStep = 1.0 / 60.0 / numSteps;

	var wireCenter = { x: simWidth / 2.0, y: simHeight / 2.0};
	var wireRadius = simMinWidth * 0.4;

	var numParticles = 5;
	var particles = [];
	var particleRadius = 0.01;

	function setupScene() 
	{
		particles = [];
		var num = 5;
		var d = 2.0 * particleRadius;
		var orig = { x: 0.5, y: 0.5};

		for (i = 0; i < num; i++) {
			for (j = 0; j < num; j++) {
				particles.push({
					pos: { x: orig.x + i * d, y : orig.y + j * d}, 
					vel: {x: 0.0, y:0.0} }
				)
			}
		}
	}

	// draw -------------------------------------------------------

	function draw() 
	{
		c.clearRect(0, 0, canvas.width, canvas.height);

		c.fillStyle = "#FF0000";

		for (i = 0; i < particles.length; i++) {
			var p = particles[i];
			c.beginPath();			
			c.arc(
				cX(p.pos), cY(p.pos), cScale * particleRadius, 0.0, 2.0 * Math.PI); 
			c.closePath();
			c.fill();
		}
	}

	// draw -------------------------------------------------------

	// var hash = {
	// 	size: 10000,
	// 	first: new Int32Array(size),
	// 	next: new Int32Array(size),
	// 	ids : new Int32Array(size)
	// };

	function initGrid() {

		for (i = 0; i < balls.length; i++) {
			ball = balls[i];
			var xi = Math.floor(ball.pos.x / cellSize);
			var yi = Math.floor(ball.pos.y / cellSize);
		}
	}

	function handleCollision(p1, p2) 
	{
		var dir = vecSub(ball2.pos, ball1.pos);
		var d = vecLength(dir);

		if (d > 0.0 && d < 2.0 * particleRadius) {
			dir = vecScale(dir, 1.0 / d);
			var corr = (2.0 * particleRadius - d) / 2.0;
			p1.pos = vecSub(p1.pos, dir, corr);
			p2.pos = vecAdd(p2.pos, dir, corr);

			var v1 = vecDot(ball1.vel, dir);
			var v2 = vecDot(ball2.vel, dir);
			var avg = (v1 + v2) / 2.0;

			p1.vel = vecAdd(p1.vel, dir, avg - v1);
			p2.vel = vecAdd(p2.vel, dir, avg - v2);
		}
	}

	function wallBounce(p) 
	{
		if (p.pos.x < p.radius) {
			p.pos.x = p.radius;
			p.vel.x = -p.vel.x;
		}
		if (p.pos.x > simWidth - p.radius) {
			p.pos.x = simWidth - p.radius;
			p.vel.x = -p.vel.x;
		}
		if (p.pos.y < p.radius) {
			p.pos.y = p.radius;
			p.vel.y = -p.vel.y;
		}

		if (p.pos.y > simHeight - p.radius) {
			p.pos.y = simHeight - p.radius;
			p.vel.y = -p.vel.y;
		}
	}

	function simulate() 
	{
		for (step = 0; step < numSteps; step++) {
			for (i = 0; i < partices.length; i++) {
				p = particles[i];
				p.vel = vecAdd(p.vel, gravity, timeStep);
				p.pos = vecAdd(p.pos, p.vel, timeStep);
			}

			for (i = 0; i < particles.length; i++)
				wallBounds(particles[i]);

			for (i = 0; i < particles.length; i++) {
				for (j = i + 1; j < particles.length; j++) 
					handleCollision(particles[i], particles[j]);
			}
		}
	}

//	var time = 0.0;

	function update() {
		// time += 0.03;
		// wireCenter.x = simWidth / 2 + wireRadius * Math.sin(time);

		simulate();
		draw();
		requestAnimationFrame(update);
	}
	
	setupScene();
	update();
	
</script> 
</body>
</html>