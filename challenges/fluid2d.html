<!-- Matthias MÃ¼ller -->

<!DOCTYPE html>
<html>

<style>
body {setup
	padding: 10px 50px;
	font-family: verdana; 
	line-height: 1.5;
	font-size: 15px;
}
</style>

<title>2D Fluid</title>
<body>

<h1>2D Fluid</h1>

<canvas id="myCanvas" width="600" height="600" style="border:3px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<br>


<script>

	class Vector {
		constructor(size) { 
			this.vals = new Int32Array(size); 
			this.maxSize = size;
			this.size = 0;
		}
		clear() {
			this.size = 0;
		}
		pushBack(val) {
			if (this.size >= this.maxSize) {
				this.maxSize *= 2;
				this.vals = new Int32Array(this.maxSize);
			}
			this.vals[this.size++] = val;
		}
	}

	// global params

	var gravity = -10;
	var particleRadius = 0.01;
	var particleDiameter = 2 * particleRadius;
	var restDensity = 1.0 / (particleDiameter * particleDiameter);
	var kernelRadius = 3.0 * particleRadius;
	var gridSpacing = kernelRadius * 1.5;
	var invGridSpacing = 1.0 / gridSpacing;
	var unilateral = true;

	var timeStep = 0.01;
	var maxVel = 0.5 * particleRadius;

	var numIters = 1;
	var numSubSteps = 10;

	// boundary
	
	var boundaries = [
		{ left : -1.1, right : -1.0, bottom : 0, top : 1.5 },
		{ left : 1.0, right : 1.1, bottom : 0, top : 1.5 },
		{ left : -0.2, right : 0.3, bottom : 0.3, top : 0.6 }
	];
	
	var fluidOrig = { left : - 0.3, bottom : 0.8 };

	var numX = 15;
	var numY = 100;
	var numParticles = numX * numY;
	
	var particles = {
		pos : new Float32Array(2 * numParticles),
		prev : new Float32Array(2 * numParticles),
		vel : new Float32Array(2 * numParticles)
	}
	
	var i, j;

	var hash = {
		size : 170111,
	
		first : new Int32Array(size),
		marks : new Int32Array(size),
		currentMark : 0,
	
		ids  : new Int32Array(numParticles),
		next : new Int32Array(numParticles),
		
		orig : { left : -10.0, bottom : -1.0 }		
	}
	
	var firstNeighbor = new Int32Array(numParticles + 1);
	var neighbors = new Vector(10 * numParticles);
	
	var grads = new Float32Array(1000);
		
	function setup()
	{
		var nr = 0;
		for (i = 0; i < numX; i++) {
			for (j = 0; j < numY; j++) {
				particles.pos[nr] = fluidOrig.left + i * particleDiameter;
				particles.pos[nr + 1] = fluidOrig.bottom + j * particleDiameter;
				particles.vel[nr] = 0.0;
				particles.vel[nr + 1] = 0.0;
				nr += 2;				
			}
		}
		
		for (i = 0; i < firstSize; i++) {
			hash.first[i] = -1;
			hash.marks[i] = 0;
		}			
	}
	
	function solveBoundaries()
	{
		var nr = 0;
		for (i = 0; i < numParticles; i++) {
			var px = particles.pos[nr];
			var py = particles.pos[nr + 1];
			
			if (py < 0.0)		// ground
				particles.pos[nr + 1] = 0.0;
				
			for (j = 0; j < boundaries.length; j++) {
				b = boundaries[j];
				if (px < b.left || px > b.right || py < b.bottom || py > b.top)
					continue;
				
				var dx, dy;
				if (px < (b.left + b.right) * 0.5) 
					dx = b.left - px;
				else
					dx = b.right - px;
					
				if (py < (b.bottom + b.top) * 0.5)
					dy = b.bottom - py;
				else
					dy = b.top - py;
					
				if (Math.abs(dx) < Math.abs(dy))
					particles.pos[nr] += dx;
				else
					particles.pos[nr+1] += dy;
			}
		
			nr += 2;
		}
	}
	
	function pushBack(array, size, maxSize, val) {
	
		if (size < maxSize)
			array[size++] = val;
		else
			array = new Int32Array(maxSize * 2);
			
	}

	
	function findNeighbors() 
	{
		// hash particles
		
		hash.currentMark++;
		
		var pos = 0;
		
		for (i = 0; i < numParticles; i++) {
			var px = particles.pos[2 * i] - hash.orig.left;
			var py = particles.pos[2 * i + 1] - hash.orig.bottom;
			
			px = Math.floor(px * invGridSpacing);
			py = Math.floor(py * invGridSpacing);
			
			var = h = ((px * 92837111) ^ (py * 689287499)) % hash.size;
						
			if (hash.marks[h] != hash.currentMark) {				
				hash.marks[h] = hash.currentMark;
				hash.first[h] = -1;
			}

			hash.next[pos] = hash.first[h];
			hash.first[h] = pos;
			hash.ids[pos] = id;
			pos++;
		}
		
		// collect neighbors
		
		neighbors.clear();

		var h2 = gridSpacing * gridSpacing;

		for (i = 0; i < numParticles; i++) {
			firstNeighbor[i] = neighbors.size;
			
			var px = particles.pos[2 * i] - hash.orig.left;
			var py = particles.pos[2 * i + 1] - hash.orig.bottom;
			
			px = Math.floor(px * invGridSpacing);
			py = Math.floor(py * invGridSpacing);
			
			var x, y;
			
			for (x = px - 1; x <= px + 1; x++) {
				for (y = py - 1; y <= py + 1; y++) {
						
					var = h = ((x * 92837111) ^ (y * 689287499)) % hash.size;
						
					if (hash.marks[h] != hash.currentMark) 
						continue;
				
					var pos = hash.first[h];
					while (pos >= 0) 
					{
						var id = hash.ids[pos];
						pos = hash.next[pos];
						
						var dx = particles.pos[2 * id] - px;
						var dy = particles.pos[2 * id + 1] - py;
						
						if (dx * dx + dy * dy < h2) 
							neighbors.pushBack(id);
					}
				}
			}
		}
		firstNeighbor[numParticles] = neighbors.size;
	}

	
	function solveFluid()
	{
		var h = kernelRadius;
		var h2 = h * h;
		var s = kernelScale;

		var avgRho = 0.0;

		for (i = 0; i < numParticles; i++) {

			var px = particles.pos[2 * i];
			var py = particles.pos[2 * i + 1];

			var first = firstNeighbor[i];
			var last = firstNeighbor[i + 1];
			var num = last - first;

			var rho = 0.0;
			var sumGrad2 = 0.0;

			var gradix = 0.0;
			var gradiy = 0.0;

			for (j = 0; j < num; j++) {
				var id = neighbors[first + j];
				
				var nx = particles.pos[2 * id] - px;
				var ny = particles.pos[2 * id + 1] - py;
				
				var r = Math.sqrt(nx * nx + ny * ny);
				nx /= r;
				ny /= r;
				
				if (r > h) {
					grads[2 * j] = 0.0;
					grads[2 * j + 1] = 0.0;
				}
				else {
					var r2 = r * r;
					var w = (h2 - r2);
					rho += s * w * w * w;
					var grad = (s * 3.0 * w * w * (-2.0 * r)) / restDensity;
					grads[j] = nx * grad;
					grads[j + 1] = ny * grad;
					gradix -= nx * grad;
					gradiy -= ny * grad;
					sumGrad2 += grad * grad;
				}
			}
			sumGrad2 += (gradix * gradix + gradiy * gradiy);

			avgRho += rho;

			var C = rho / restDensity - 1.0f;
			if (unilateral && C < 0.0f)
				continue;

			var lambda = -C / (sumGrad2 + 0.0001f);

			for (j = 0; j < num; j++) {
				var id = neighbors[first + j];
				if (id == i) {
					particles.pos[2 * id] += lambda * gradix;
					particles.pos[2 * id + 1] += lambda * gradiy;
				
				}
				else {
					particles.pos[2 * id].pos += lambda * grads[2 * j];
					particles.pos[2 * id + 1].pos += lambda * grads[2 * j + 1];
				}
			}
		}
	}
	
	function simulate()
	{
		findNeighbors();
		
		var dt = timeStep / numSubSteps;
		var step;
		
		for (step = 0; step < numSubSteps; step ++) {
			
			// predict
			
			var nr = 0;
			for (i = 0; i < numParticles; i++) {
				particles.vel[nr + 1] += gravity * dt;
				particles.prev[nr] = particles.pos[nr];
				particles.prev[nr + 1] = particles.pos[nr + 1];
				particles.pos[nr] += particles.vel[nr] * dt;
				particles.pos[nr + 1] += particles.vel[nr + 1] * dt;
				nr += 2;
			}

			// solve
			
			solveBoundaries();
			solveFluid();
			
			// derive velocities
			
			nr = 0;
			for (i = 0; i < numParticles; i++) {
				var vx = particles.pos[nr] - particles.prev[nr];
				var vy = particles.pos[nr + 1] - particles.prev[nr + 1];

				// CFL
				
				var v = Math.sqrt(vx * vx + vy * vy);
				if (v > maxVel) {
					vx *= maxVel / v;
					vy *= maxVel / v;
					particles.pos[nr] = particles.prev[nr] + vx;
					particles.pos[nr + 1] = particles.prev[nr + 1] + vy;
				}				
				particles.vel[nr] = vx / dt;
				particles.vel[nr + 1] = vy / dt;
				nr += 2;
			}
		}		
	}
	
	function draw() 
	{
		var canvas = document.getElementById("myCanvas");
		var c = canvas.getContext("2d");
		c.clearRect(0, 0, canvas.width, canvas.height);

		var scale = 200;		
		
		var ox = canvas.width / 2;
		var oy = canvas.height - 20;
		var i;
		
		// particles

		c.fillStyle = "#0000FF";
		
		var nr = 0;
		for (i = 0; i < numParticles; i++) {
		
			var px = ox + particles.pos[nr] * scale;
			var py = oy - particles.pos[nr + 1] * scale;
			
			nr += 2;

			c.beginPath();			
			c.arc(
				px, py, particleRadius * scale, 0, Math.PI*2, true); 
			c.closePath();
			c.fill();
		}
		
		// boundaries

		c.fillStyle = "#eeeeee";
		
		for (i = 0; i < boundaries.length; i++) {
			var b = boundaries[i];
			var left = ox + b.left * scale;
			var width = (b.right - b.left) * scale;
			var top = oy - b.top * scale;
			var height = (b.top - b.bottom) * scale; 
			
			c.beginPath();
			c.rect(left, top, width, height);
			c.stroke();			
		}
		
		c.beginPath();
		c.moveTo(0, oy); c.lineTo(canvas.width, oy);
		c.stroke();
	}	
		
	function step() 
	{
		simulate();		
		draw();
		window.requestAnimationFrame(step);
	}
		
	// main
	
	setup();
	step();

</script> 
</body>
</html>
