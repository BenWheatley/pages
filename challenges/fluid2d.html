<!-- Matthias MÃ¼ller -->

<!DOCTYPE html>
<html>

<style>
body {setup
	padding: 10px 50px;
	font-family: verdana; 
	line-height: 1.5;
	font-size: 15px;
}
</style>

<title>2D Fluid</title>
<body>

<h1>2D Fluid</h1>

<canvas id="myCanvas" width="800" height="600" style="border:3px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<br>


<script>

	class Vector {
		constructor(size) { 
			this.vals = new Int32Array(size); 
			this.maxSize = size;
			this.size = 0;
		}
		clear() {
			this.size = 0;
		}
		pushBack(val) {
			if (this.size >= this.maxSize) {
				this.maxSize *= 2;
				var old = this.vals;
				this.vals = new Int32Array(this.maxSize);
				for (i = 0; i < old.length; i++)
					this.vals[i] = old[i];
			}
			this.vals[this.size++] = val;
		}
	}

	var canvas = document.getElementById("myCanvas");
	var c = canvas.getContext("2d");
		
	var drawOrig = { x : canvas.width / 2, y : canvas.height - 20};
	var drawScale = 200;


	// global params

	var gravity = -10;
	var particleRadius = 0.01;
	var particleDiameter = 2 * particleRadius;
	var restDensity = 1.0 / (particleDiameter * particleDiameter);
	var kernelRadius = 3.0 * particleRadius;
	var h2 = kernelRadius * kernelRadius;
	var kernelScale = 4.0 / (Math.PI * h2 * h2 * h2 * h2);		
	// 2d poly6 (SPH based shallow water simulation

	
	var gridSpacing = kernelRadius * 1.5;
	var invGridSpacing = 1.0 / gridSpacing;
	var unilateral = true;

	var timeStep = 0.01;
	var maxVel = 0.4 * particleRadius;

	var numIters = 1;
	var numSubSteps = 10;

	// boundary
	
	var width = 1.0;
	var height = 2.0;
	
	var boundaries = [
		{ left : -width * 0.5 - 0.1, right : -width * 0.5, bottom : -0.01, top : height },
		{ left : width * 0.5, right : width * 0.5 + 0.1, bottom : -0.01, top : height },
	];
	
	var fluidOrig = { left : - 0.3, bottom : 1.8 };

//	var numX = 20;
//	var numY = 750;

	var numX = 10;
	var numY = 1000;
	var numParticles = numX * numY;
	
	var particles = {
		pos : new Float32Array(2 * numParticles),
		prev : new Float32Array(2 * numParticles),
		vel : new Float32Array(2 * numParticles)
	}
	
	var i, j;
	
	var hashSize = 370111;

	var hash = {
		size : hashSize,
	
		first : new Int32Array(hashSize),
		marks : new Int32Array(hashSize),
		currentMark : 0,
	
		next : new Int32Array(numParticles),
		
		orig : { left : -100.0, bottom : -1.0 }		
	}
	
	var firstNeighbor = new Int32Array(numParticles + 1);
	var neighbors = new Vector(10 * numParticles);
	
	var grads = new Float32Array(1000);
		
	function setup()
	{
		var nr = 0;
		for (j = 0; j < numY; j++) {
			for (i = 0; i < numX; i++) {
				particles.pos[nr] = fluidOrig.left + i * particleDiameter;
				particles.pos[nr + 1] = fluidOrig.bottom + j * particleDiameter;
				particles.vel[nr] = 0.0;
				particles.vel[nr + 1] = 0.0;
				nr += 2;				
			}
		}
		
		for (i = 0; i < hashSize; i++) {
			hash.first[i] = -1;
			hash.marks[i] = 0;
		}			
	}
	
	function solveBoundaries()
	{
		var minX = canvas.width * 0.5 / drawScale;
		
		for (i = 0; i < numParticles; i++) {
			var px = particles.pos[2 * i];
			var py = particles.pos[2 * i + 1];
			
			if (py < 0.0) 		// ground
				particles.pos[2 * i + 1] = 0.0;
			
			if (px < -minX) 
				particles.pos[2 * i] = -minX;
			if (px > minX) 
				particles.pos[2 * i] = minX;

							
			for (j = 0; j < boundaries.length; j++) {
				b = boundaries[j];
				if (px < b.left || px > b.right || py < b.bottom || py > b.top)
					continue;
				
				var dx, dy;
				if (px < (b.left + b.right) * 0.5) 
					dx = b.left - px;
				else
					dx = b.right - px;
					
				if (py < (b.bottom + b.top) * 0.5)
					dy = b.bottom - py;
				else
					dy = b.top - py;
					
				if (Math.abs(dx) < Math.abs(dy))
					particles.pos[2 * i] += dx;
				else
					particles.pos[2 * i + 1] += dy;
			}		
		}
	}
		
	function findNeighbors() 
	{
		// hash particles
		
		hash.currentMark++;
		
		
		for (i = 0; i < numParticles; i++) {
			var px = particles.pos[2 * i];
			var py = particles.pos[2 * i + 1];
			
			var gx = Math.floor((px - hash.orig.left) * invGridSpacing);
			var gy = Math.floor((py - hash.orig.bottom) * invGridSpacing);
			
			var h = (Math.abs((gx * 92837111) ^ (gy * 689287499))) % hash.size;
						
			if (hash.marks[h] != hash.currentMark) {				
				hash.marks[h] = hash.currentMark;
				hash.first[h] = -1;
			}

			hash.next[i] = hash.first[h];
			hash.first[h] = i;
		}
		
		// collect neighbors
		
		neighbors.clear();

		var h2 = gridSpacing * gridSpacing;

		for (i = 0; i < numParticles; i++) {
			firstNeighbor[i] = neighbors.size;
			
			var px = particles.pos[2 * i];
			var py = particles.pos[2 * i + 1];
			
			var gx = Math.floor((px - hash.orig.left) * invGridSpacing);
			var gy = Math.floor((py - hash.orig.bottom) * invGridSpacing);
			
			var x, y;
			
			for (x = gx - 1; x <= gx + 1; x++) {
				for (y = gy - 1; y <= gy + 1; y++) {
						
					var h = (Math.abs((x * 92837111) ^ (y * 689287499))) % hash.size;
						
					if (hash.marks[h] != hash.currentMark) 
						continue;
				
					var id = hash.first[h];
					while (id >= 0) 
					{
						var dx = particles.pos[2 * id] - px;
						var dy = particles.pos[2 * id + 1] - py;
						
						if (dx * dx + dy * dy < h2) 
							neighbors.pushBack(id);

						id = hash.next[id];						
					}
				}
			}
		}
		firstNeighbor[numParticles] = neighbors.size;
	}

	
	function solveFluid()
	{
		var h = kernelRadius;
		var h2 = h * h;
		var s = kernelScale;

		var avgRho = 0.0;

		for (i = 0; i < numParticles; i++) {

			var px = particles.pos[2 * i];
			var py = particles.pos[2 * i + 1];

			var first = firstNeighbor[i];
			var last = firstNeighbor[i + 1];
			var num = last - first;

			var rho = 0.0;
			var sumGrad2 = 0.0;

			var gradix = 0.0;
			var gradiy = 0.0;
			
			var vorticity = 0.0;

			for (j = 0; j < num; j++) {
				var id = neighbors.vals[first + j];
				
				var qx = particles.pos[2 * id];
				var qy = particles.pos[2 * id + 1];				
				var rx = qx - px;
				
				var ry = qy - py;
				var r = Math.sqrt(rx * rx + ry * ry);
				var nx = rx;
				var ny = ry;
				
				if (r > 0) {
					nx /= r;
					ny /= r;
				}
				
				if (r > h) {
					grads[2 * j] = 0.0;
					grads[2 * j + 1] = 0.0;
				}
				else {
					var r2 = r * r;
					var w = (h2 - r2);
					var kernel = s * w * w * w;
					rho += kernel;
					var grad = (s * 3.0 * w * w * (-2.0 * r)) / restDensity;
					grads[2 * j] = nx * grad;
					grads[2 * j + 1] = ny * grad;
					gradix -= nx * grad;
					gradiy -= ny * grad;
					sumGrad2 += grad * grad;

					var vx = qx - particles.prev[2 * id];
					var vy = qy - particles.prev[2 * id + 1];				
					
					vorticity += kernel * (rx * vy - ry * vx);
				}
			}
			sumGrad2 += (gradix * gradix + gradiy * gradiy);

			avgRho += rho;

			var C = rho / restDensity - 1.0;
			if (unilateral && C < 0.0)
				continue;

			var lambda = -C / (sumGrad2 + 0.0001);

			for (j = 0; j < num; j++) {
				var id = neighbors.vals[first + j];
				if (id == i) {
					particles.pos[2 * id] += lambda * gradix;
					particles.pos[2 * id + 1] += lambda * gradiy;
				
				}
				else {
					particles.pos[2 * id] += lambda * grads[2 * j];
					particles.pos[2 * id + 1] += lambda * grads[2 * j + 1];
				}
															
				var rx = particles.pos[2 * id] - px;
				var ry = particles.pos[2 * id + 1] - py;				
				var r2 = rx * rx + ry * ry;
				if (r2 < h2) {
					var w = (h2 - r2);
					var kernel = s * w * w * w;
					var vx = -ry * vorticity;
					var vy = rx * vorticity;					
					particles.pos[2 * id] += 0.0001 * kernel * vx;
					particles.pos[2 * id + 1] += 0.0001 * kernel * vy;
				}
			}
		}
	}
	
	function simulate()
	{
		findNeighbors();
		
		var dt = timeStep / numSubSteps;
		var step;
		
		for (step = 0; step < numSubSteps; step ++) {
			
			// predict
			
			var nr = 0;
			for (i = 0; i < numParticles; i++) {
				particles.vel[nr + 1] += gravity * dt;
				particles.prev[nr] = particles.pos[nr];
				particles.prev[nr + 1] = particles.pos[nr + 1];
				particles.pos[nr] += particles.vel[nr] * dt;
				particles.pos[nr + 1] += particles.vel[nr + 1] * dt;
				nr += 2;
			}

			// solve
			
			solveBoundaries();
			solveFluid();
			
			// derive velocities
			
			nr = 0;
			for (i = 0; i < numParticles; i++) {
				var vx = particles.pos[nr] - particles.prev[nr];
				var vy = particles.pos[nr + 1] - particles.prev[nr + 1];

				// CFL
				
				var v = Math.sqrt(vx * vx + vy * vy);
				if (v > maxVel) {
					vx *= maxVel / v;
					vy *= maxVel / v;
					particles.pos[nr] = particles.prev[nr] + vx;
					particles.pos[nr + 1] = particles.prev[nr + 1] + vy;
				}				
				particles.vel[nr] = vx / dt;
				particles.vel[nr + 1] = vy / dt;
				nr += 2;
			}
		}		
	}
	
	function draw() 
	{
		c.clearRect(0, 0, canvas.width, canvas.height);
	
		// particles
		
		var nr = 0;
		for (i = 0; i < numParticles; i++) {

			if ((Math.floor(i / (200 * numX)) % 2) == 0)
				c.fillStyle = "#0000FF";
			else
				c.fillStyle = "#FF0000";

		
			var px = drawOrig.x + particles.pos[nr] * drawScale;
			var py = drawOrig.y - particles.pos[nr + 1] * drawScale;
			
			nr += 2;

			c.beginPath();			
			c.arc(
				px, py, particleRadius * drawScale, 0, Math.PI*2, true); 
			c.closePath();
			c.fill();
		}
		
		// boundaries

		c.fillStyle = "#eeeeee";
		
		for (i = 0; i < boundaries.length; i++) {
			var b = boundaries[i];
			var left = drawOrig.x + b.left * drawScale;
			var width = (b.right - b.left) * drawScale;
			var top = drawOrig.y - b.top * drawScale;
			var height = (b.top - b.bottom) * drawScale; 
			
			c.beginPath();
			c.rect(left, top, width, height);
			c.stroke();			
		}
		
		c.beginPath();
		c.moveTo(0, drawOrig.y); c.lineTo(canvas.width, drawOrig.y);
		c.stroke();
	}	
		
	function step() 
	{
		simulate();		
		draw();
		window.requestAnimationFrame(step);
	}
		
	// main
	
	setup();
	step();

</script> 
</body>
</html>
