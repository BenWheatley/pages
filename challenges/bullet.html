<html>
    <head>
        <meta charset="utf-8">
        <title>JS 3D Physics</title>
        <style>
            body { margin: 0; }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/ammo.js"></script>
        <script>

            //variable declaration section
            let physicsWorld, scene, camera, renderer, rigidBodies = [];
            let colGroupPlane = 1, colGroupRedBall = 2, colGroupGreenBall = 4

            //Ammojs Initialization
            Ammo().then(start)

            function start (){

                tmpTrans = new Ammo.btTransform();

                setupPhysicsWorld();

                setupGraphics();
                createObjects();

                renderFrame();

            }

            function setupPhysicsWorld(){

                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
				
				let info = physicsWorld.getSolverInfo();
				info.m_numIterations = 40;
                physicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));

            }


            function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xbfd1e5 );

                //create camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 5000 );
                camera.position.set( 0, 2, 3 );
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                //Add hemisphere light
                let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
                hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
                hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
                hemiLight.position.set( 0, 50, 0 );
                scene.add( hemiLight );

                //Add directional light
                let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                let d = 50;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;

                //Setup the renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;

                renderer.shadowMap.enabled = true;

            }

        
            function renderFrame(){

                let deltaTime = clock.getDelta();

                updatePhysics( deltaTime );

                renderer.render( scene, camera );

                requestAnimationFrame( renderFrame );

            }
   

            function createObjects(){
                
				let numObjects = 20;
				let dx = 0.02;
				let dy = 0.04;
				let dz = 0.02;

                let pos = {x: 0, y: numObjects * dy - dy, z: dz};

                let dims = {x: dx, y: dy, z: dz};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = dx * dy * dz;

                let transform = new Ammo.btTransform();
				
				let lastBody;
								
				for (let i = 0; i < numObjects; i++) {                

					// graphics

					let boxVis = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf78a1d}));

					boxVis.position.set(pos.x, pos.y - i * dy, pos.z);
					boxVis.scale.set(dims.x, dims.y, dims.z);

					boxVis.castShadow = true;
					boxVis.receiveShadow = true;

					scene.add(boxVis);

					// physics
                
					transform.setIdentity();
					transform.setOrigin( new Ammo.btVector3( pos.x, pos.y - i * dy, pos.z) );
					transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
					motionState = new Ammo.btDefaultMotionState( transform );

					let boxColShape = new Ammo.btBoxShape( new Ammo.btVector3( dims.x * 0.5, dims.y * 0.5, dims.z * 0.5 ) );
					boxColShape.setMargin( 0.001 );

					localInertia = new Ammo.btVector3( 0, 0, 0 );
					boxColShape.calculateLocalInertia( mass, localInertia );

					rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, boxColShape, localInertia );
					let boxBody = new Ammo.btRigidBody( rbInfo );

					physicsWorld.addRigidBody( boxBody, colGroupGreenBall, colGroupRedBall );
                
					boxVis.userData.physicsBody = boxBody;
					rigidBodies.push(boxVis);

					// create joint
					
					let s = i % 2 == 0 ? -0.5 : 0.5;
					let lastPivot = new Ammo.btVector3( s * dims.x, -0.5 * dims.y, s * dims.z );
					let pivot = new Ammo.btVector3( s * dims.x, 0.5 * dims.y, s * dims.z );
					let p2p;
					if (i == 0)
						p2p = new Ammo.btPoint2PointConstraint( boxBody, pivot);
					else
						p2p = new Ammo.btPoint2PointConstraint( lastBody, boxBody, lastPivot, pivot);
						
					physicsWorld.addConstraint( p2p, false );
					
					lastBody = boxBody;
				}
            }




            function updatePhysics( deltaTime ){
			
				physicsWorld.stepSimulation( deltaTime );

                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
				}

            }


        </script>
    </body>
</html>