<!DOCTYPE html>
<html lang="en">
	<head>
		<title>test three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	
	<body>

		<div id="container"></div>

		<script src="https://threejs.org/build/three.js"></script>

		<script type="module">
		
			var scene;
			var camera;
			var renderer;
			var container = document.getElementById( 'container' );

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var grabbedObject = null;
			var grabDistance = 0.0;

			var raycaster = new THREE.Raycaster();
			raycaster.layers.set( 1 );
			var mousePos = new THREE.Vector2();
			var mouseDown = false;
			var cameraLookAt = new THREE.Vector3(0.0, 1.0, 0.0);
			var cameraDirX = new THREE.Vector3(0.0, 0.0, 0.0);
			var cameraDirY = new THREE.Vector3(0.0, 0.0, 0.0);
			var cameraDirZ = new THREE.Vector3(0.0, 0.0, 0.0);

			// physics

			var gravity = new THREE.Vector3(0.0, -10.0, 0.0);
					
			init();
			animate();			

			function init() {
			
				scene = new THREE.Scene();
				
				// Lights
				
				scene.add( new THREE.AmbientLight( 0x505050 ) );	
				scene.fog = new THREE.Fog( 0x000000, 0, 15 );				

				var spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.2;
				spotLight.position.set( 2, 3, 3 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 3;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				scene.add( spotLight );

				var dirLight = new THREE.DirectionalLight( 0x55505a, 1 );
				dirLight.position.set( 0, 3, 0 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 10;

				dirLight.shadow.camera.right = 1;
				dirLight.shadow.camera.left = - 1;
				dirLight.shadow.camera.top	= 1;
				dirLight.shadow.camera.bottom = - 1;

				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				scene.add( dirLight );
				
				// Geometry

				var material = new THREE.MeshPhongMaterial( {
					color: 0x80ee10,
					shininess: 100,
					side: THREE.DoubleSide
				} );

				// var geometry = new THREE.SphereGeometry( 0.2, 20, 20 );

				// var object = new THREE.Mesh( geometry, material );
				// object.position.set(0, 0.5, 0);
				// object.castShadow = true;
				// object.layers.enable( 1 );
				// scene.add( object );

				var ground = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 20, 20, 1, 1 ),
					new THREE.MeshPhongMaterial( { color: 0xa0adaf, shininess: 150 } )
				);

				ground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z
				ground.receiveShadow = true;
				scene.add( ground );
				
				var helper = new THREE.GridHelper( 20, 50 );
				helper.material.opacity = 0.5;
				helper.material.transparent = true;
				helper.position.set(0, 0.001, 0);
				scene.add( helper );				
				
				// Renderer

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				window.addEventListener( 'resize', onWindowResize, false );
				container.appendChild( renderer.domElement );
				
				// Camera
						
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.set( 0, 1, 3 );				
				camera.lookAt(cameraLookAt);
				camera.updateMatrixWorld();	
				
				scene.add( camera );

				createObjects();

				// interaction

				container.addEventListener( 'mousedown', onMouse, false );
				container.addEventListener( 'mousemove', onMouse, false );
				container.addEventListener( 'mouseup', onMouse, false );
				container.addEventListener( 'wheel', onWheel, false );
				container.addEventListener( 'touchstart', onTouch, false );
				container.addEventListener( 'touchend', onTouch, false );
				container.addEventListener( 'touchmove', onTouch, false );			
			}

			function animate() {

				requestAnimationFrame( animate );
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			// Pose  -----------------------------------------------------------

			class Pose {
				constructor() {
					this.p = new THREE.Vector3(0.0, 0.0, 0.0);
					this.q = new THREE.Quaternion(0.0, 0.0, 0.0, 1.0);					
				}
				transform(v) {
					v.applyQuaternion(this.q);
					v.add(this.p);
				}
				rotate(v) {
					v.applyQuaternion(this.q);
				}
				invTransform(v) {
					v.sub(this.p);
					v.applyQuaternion(this.q.conjugate());
				}
				rotateInv(v) {
					v.applyQuaternion(this.q.conjugate());
				}
				transform(pose) {
					this.q.multiply(pose.q);
					this.rotate(pose.t);
					pose.t.add(this.p);
				}
				copy(pose) {
					this.p.copy(pose.p);
					this.q.copy(pose.q);
				}
				clone(pose) {
					this.p = pose.p.clone();
					this.q = pose.q.clone();
				}
			}

			// Rigid body class  -----------------------------------------------------------

			class Body {
				constructor(pose, mesh) 
				{ 
					this.pose = pose.clone();
					this.prevPose = pose.clone();
					this.origPose = pose.clone();
					this.vel = new THREE.Vector3(0.0, 0.0, 0.0);
					this.omega = new THREE.Vector3(0.0, 0.0, 0.0);
					this.tempQ = new THREE.Quaternion(0.0, 0.0, 0.0, 1.0);
					this.tempV = new THREE.Vector3(0.0, 0.0, 0.0);
					
					this.invMass = 1.0;
					this.invInertia = new THREE.Vector3();
					this.mesh = mesh;
					this.tempV.set(1.0, 1.0, 1.0);
					this.mesh.matrixWorld.compose(this.pose.p, this.pose.q, this.tempV);	
					mesh.userData.physicsBody = this;
				}

				setBox(wx, wy, wz, density = 1.0) {
					let mass = wx * wy * wz * density;
					this.invMass = 1.0 / mass;
					mass /= 12.0;
					this.invInertia.set(
						1.0 / (wy * wy + wz * wz) / mass,
						1.0 / (wz * wz + wx * wx) / mass,
						1.0 / (wx * wx + wy * wy) / mass);
				}

				rotateLinearized(rot, scale = 0.0) {
					this.tempQ.set(rot.x * scale, rot.y * scale, rot.z * scale, 0.0);					
					this.tempQ.multiply(this.pose.q);
					this.pose.q.set(this.pose.q.x + 0.5 * this.tempQ.x, this.pose.q.y + 0.5 * this.tempQ.y, 
							this.pose.q.z + 0.5 * this.tempQ.z, this.pose.q.w + 0.5 * this.tempQ.w);
					this.pose.q.normalize();
				}

				integrate(dt) {
					this.prevPose.copy(this.pose);
					this.vel.addScaledVector(gravity, dt);					
					this.pose.p.addScaledVector(this.vel, dt);
					rotateLinearized(this.omega, dt);
				}

				update(dt) {
					this.vel.subVectors(this.pose.p, this.prevPose.p);
					this.vel.set(this.vel.x / dt, this.vel.y / dt, this.vel.z / dt);
					this.tempQ.multiplyQuaternions(this.pose.q, this.prevPose.q.conjugate());
					this.omega.set(2.0 / dt * tempQ.q.x, 2.0 / dt * tempQ.y, 2.0 / dt * tempQ.z);
					if (this.tempQ.w < 0.0)
						this.omega.set(-this.omega.x, -this.omega.y, -this.omega.z);

					this.tempV.set(1.0, 1.0, 1.0);
					this.mesh.matrixWorld.compose(this.pose.p, this.pose.q, this.tempV);
				}

				applyCorrection(corr, pos = null) {
					if (pos === null) 
						this.tempV.copy(corr);
					else {
						this.pose.p.addScaledVector(corr, this.invMass);
						this.tempV.subVectors(pos, pose.p);
						this.tempV.cross(corr);
					}
					this.pose.rotateInv(this.tempV);
					this.tempV.set(this.invInertia.x * this.tempV.x, 
						this.invInertia.y * this.tempV.y, this.invInertia.z * this.tempV.z);
					this.pose.rotate(this.tempV);
					rotateLinearized(this.tempV);
				}

				getInverseMass(normal, pos = null) {
					if (pos === null) 
						this.tempV.copy(normal);
					else {
						this.tempV.subVectors(pos, pose.p);
						this.tempV.cross(normal);
					}
					this.pose.rotateInv(this.tempV);
					let w = 
						this.tempV.x * this.tempV.x * invInertia.x +
						this.tempV.y * this.tempV.y * invInertia.y +
						this.tempV.z * this.tempV.z * invInertia.z;
					if (pos !== null)
						w += this.invMass;
					return w;
				}

				applyPairPosCorrection(body1, corr, compliance, dt, pos0 = null, pos1 = null) {
					this.tempV.copy(corr);
					let C = corr.length();
					if ( C == 0.0)
						return;
					this.tempV.normalize();

					let w0 = 0.0;
					let w1 = 0.0;
					let w0 = getPosInverseMass(this.tempV, pos0);
					let w1 = body1 ? body1.getPosInverseMass(this.tempV, pos1) : 0.0;

					let w = w0 + w1;
					if (w == 0.0)
						return;

					let lambda = -C / (w + compliance / dt / dt);
					this.tempV.multiplyScalar(-lambda);
					applyPosCorrection(this.tempV, pos0);
					if (body1) {
						this.tempV.multiplyScalar(-1.0);
						body1.applyPosCorrection(this.tempV, pos1);
					}
				}
			}

			// Joint class  -----------------------------------------------------------

			class Joint {
				constructor(body0, body1, localPose0, localPose1) 
				{ 
					this.body0 = body0;
					this.body1 = body1;
					this.localPose0 = localPose0.clone();
					this.localPose1 = localPose1.clone();
					this.globalPose0 = localPose0.clone();
					this.globalPose1 = localPose1.clone();
					this.corr = new THREE.Vector3(0.0, 0.0, 0.0);
					this.compliance = 0.0;
				}

				solve(dt) {
					this.globalPos0.copy(this.localPos0);
					if (body0)
						body0.pose.transform(this.globalPos0);
					this.globalPos1.copy(this.localPos1);
					if (body1)
						body1.pose.transform(this.globalPos1);
					this.corr.subVectors(this.globalPos1, this.globalPos0);

					if (this.body0 === null)
						this.body0.applyPairCorrection(this.body1, this.corr, this.compliance, dt, 
							this.gloabePos0.p, this.globalPose1.p);
					else {
						this.corr.multiplyScalar(-1.0);
						this.body1.applyPairCorrection(this.body0, this.corr, this.compliance, dt, 
							this.gloabePos1.p, this.globalPose0.p);
					}
				}
			}

			var bodies = [];
			var joints = [];

			// create objects  -----------------------------------------------------------

			function createObjects(){
                
				let numObjects = 100;
				let dx = 0.02;
				let dy = 0.04;
				let dz = 0.02;

                let pos = {x: 0, y: numObjects * dy - dy, z: dz};

                let dims = {x: dx, y: dy, z: dz};
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = dx * dy * dz;

				let pose = new Pose();

				let lastBody = null;
								
				for (let i = 0; i < numObjects; i++) {                

					// graphics

					let boxVis = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf78a1d}));

					boxVis.scale.set(dims.x, dims.y - 0.006, dims.z);
					boxVis.name = "box " + i;
					boxVis.layers.enable( 1 );

					boxVis.castShadow = true;
					boxVis.receiveShadow = true;

					scene.add(boxVis);

					// physics

					pose.p.set(pos.x, pos.y - i * dy, pos.z);

					let box = new Body(pose, boxVis);
					bodies.push(box);

					let joint = new Joint()

					joints.push(joint);
					
					let s = i % 2 == 0 ? -0.5 : 0.5;
					let lastPivot = new Ammo.btVector3( s * dims.x, -0.5 * dims.y, s * dims.z );
					let pivot = new Ammo.btVector3( s * dims.x, 0.5 * dims.y, s * dims.z );
					let p2p;
					if (i == 0)
						p2p = new Ammo.btPoint2PointConstraint( boxBody, pivot);
					else
						p2p = new Ammo.btPoint2PointConstraint( lastBody, boxBody, lastPivot, pivot);
						
					physicsWorld.addConstraint( p2p, false );
					
					lastBody = boxBody;
				}
			}

	

			// scene interaction -----------------------------------------------------------

			function handleCameraMotion(dx, dy) {
				let scale = 0.01;
				let prev = camera.position.distanceTo(cameraLookAt);
				cameraDirZ.subVectors(cameraLookAt, camera.position);
				cameraDirX.set(cameraDirZ.z, 0.0, -cameraDirZ.x, 0.0);
				cameraDirX.normalize();
				cameraDirY.crossVectors(cameraDirZ, cameraDirX);
				cameraDirY.normalize();
				camera.position.addScaledVector(cameraDirX, scale * dx);
				camera.position.addScaledVector(cameraDirY, scale * dy);
				cameraDirZ.subVectors(cameraLookAt, camera.position);
				cameraDirZ.normalize();
				let delta = camera.position.distanceTo(cameraLookAt) - prev;
				camera.position.addScaledVector(cameraDirZ, -delta);
				camera.lookAt(cameraLookAt);
			}

			function handleCameraZoom(d) {
				let scale = 1.0 - 0.003 * d;
				let dist = camera.position.distanceTo(cameraLookAt);
				if (d > 0.0 && dist < 1.0 || d < 0.0 && dist > 5.0)
					return;

				camera.position.set(
					cameraLookAt.x + (camera.position.x - cameraLookAt.x) * scale,				
					cameraLookAt.y + (camera.position.y - cameraLookAt.y) * scale,				
					cameraLookAt.z + (camera.position.z - cameraLookAt.z) * scale);	
				camera.updateMatrixWorld();
			}

			function startGrab(x, y) {
				grabbedObject = null;
				mousePos.x = ( x / window.innerWidth ) * 2 - 1;
				mousePos.y = - ( y / window.innerHeight ) * 2 + 1;
				raycaster.setFromCamera( mousePos, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				if (intersects.length > 0) {
					grabbedObject = intersects[0].object;	// 0 is closest
					grabDistance = intersects[0].distance;
					console.log(grabbedObject.name);
				}
			}

			function moveGrabbed(x, y) {
				if (!grabbedObject)
					return;

				mousePos.x = ( x / window.innerWidth ) * 2 - 1;
				mousePos.y = - ( y / window.innerHeight ) * 2 + 1;
				raycaster.setFromCamera( mousePos, camera );
				raycaster.ray.origin + raycaster.ray.direction * grabDistance;
			}

			function endGrab() {
				grabbedObject = null;
			}
						
			
			function onMouse( evt ) 
			{
				event.preventDefault();
				if (evt.type == "mousedown") {
					startGrab(evt.clientX, evt.clientY);
					mouseDown = true;
				}
				else if (evt.type == "mousemove" && mouseDown) {
					if (grabbedObject)
						moveGrabbed(evt.clientX, evt.clientY);
					else
						handleCameraMotion(evt.movementX, evt.movementY);
				}
				else if (evt.type == "mouseup" || evt.type == "mouseout") {
					mouseDown = false;
					endGrab();
				}
			}

			function onWheel( evt ) 
			{
				handleCameraZoom(-evt.deltaY * 0.1 );
			}

			var touchCoords = [ { x : 0.0, y : 0.0}, { x : 0.0, y : 0.0}];

			function onTouch( evt ) {
				event.preventDefault();

				if (evt.type == "touchdown") {
					if (evt.touches.length == 1)
						startGrab(evt.touches[0].clientX, evt.touches[0].clientY);
				}

				if (evt.type == "touchmove") {
					if (grabbedObject) {
						moveGrabbed(evt.touches[0].clientX, evt.touches[0].clientY);
					}
					else {
						if (evt.touches.length == 1) {
							handleCameraMotion(
								evt.touches[0].clientX - touchCoords[0].x,
								evt.touches[0].clientY - touchCoords[0].y);
						}
						else if (evt.touches.length == 2) {
							let px = (touchCoords[1].x - touchCoords[0].x);
							let py = (touchCoords[1].y - touchCoords[0].y);
							let p = Math.sqrt(px * px + py * py);
							let dx = (evt.touches[1].clientX - evt.touches[0].clientX);
							let dy = (evt.touches[1].clientY - evt.touches[0].clientY);
							let d = Math.sqrt(dx * dx + dy * dy);
							handleCameraZoom(d - p);
						}
					}
				}
				else if (evt.type == "touchup") {
					if (evt.touches.length == 0)
						endGrab();
				}
				if (evt.touches.length <= 2) {
					for (let i = 0; i < evt.touches.length; i++) {
						touchCoords[i].x = evt.touches[i].clientX;
						touchCoords[i].y = evt.touches[i].clientY;
					}
				}				
			}					

		</script>

	</body>
</html>