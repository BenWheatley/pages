<!DOCTYPE html>
<html lang="en">
	<head>
		<title>test three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	
	<body>

		<div id="container"></div>

		<script src="https://threejs.org/build/three.js"></script>

		<script type="module">

			// physics scene

			var gravity = new THREE.Vector3(0.0, -10.0, 0.0);
			var numSubsteps = 40;
			var timeStep = 1.0 / 60.0;
			var rotDamping = 10.0;
			var transDamping = 100.0;

			var numObjects = 100;
			var objectsSize = new THREE.Vector3(0.02, 0.04, 0.02);
			var lastObjectsSize = new THREE.Vector3(0.2, 0.04, 0.2);

			var bodies = [];
			var joints = [];

			// visual scene

			var scene;
			var camera;
			var renderer;
			var container = document.getElementById( 'container' );

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var grabDistance = 0.0;
			var grabJoint = null;

			var raycaster = new THREE.Raycaster();
			raycaster.layers.set( 1 );
			var mousePos = new THREE.Vector2();
			var mouseDown = false;
			var cameraLookAt = new THREE.Vector3(0.0, 2.5, 0.0);
			var camPosition = new THREE.Vector3(0.0, 2.5, 5.0);
			var cameraDirX = new THREE.Vector3(0.0, 0.0, 0.0);
			var cameraDirY = new THREE.Vector3(0.0, 0.0, 0.0);
			var cameraDirZ = new THREE.Vector3(0.0, 0.0, 0.0);
					
			function init() {
			
				scene = new THREE.Scene();
				
				// Lights
				
				scene.add( new THREE.AmbientLight( 0x505050 ) );	
				scene.fog = new THREE.Fog( 0x000000, 0, 15 );				

				var spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.2;
				spotLight.position.set( 2, 3, 3 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 3;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				scene.add( spotLight );

				var dirLight = new THREE.DirectionalLight( 0x55505a, 1 );
				dirLight.position.set( 0, 3, 0 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 10;

				dirLight.shadow.camera.right = 1;
				dirLight.shadow.camera.left = - 1;
				dirLight.shadow.camera.top	= 1;
				dirLight.shadow.camera.bottom = - 1;

				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				scene.add( dirLight );
				
				// Geometry

				var material = new THREE.MeshPhongMaterial( {
					color: 0x80ee10,
					shininess: 100,
					side: THREE.DoubleSide
				} );

				// var geometry = new THREE.SphereGeometry( 0.2, 20, 20 );

				// var object = new THREE.Mesh( geometry, material );
				// object.position.set(0, 0.5, 0);
				// object.castShadow = true;
				// object.layers.enable( 1 );
				// scene.add( object );

				var ground = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 20, 20, 1, 1 ),
					new THREE.MeshPhongMaterial( { color: 0xa0adaf, shininess: 150 } )
				);

				ground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z
				ground.receiveShadow = true;
				scene.add( ground );
				
				var helper = new THREE.GridHelper( 20, 50 );
				helper.material.opacity = 0.5;
				helper.material.transparent = true;
				helper.position.set(0, 0.001, 0);
				scene.add( helper );				
				
				// Renderer

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				window.addEventListener( 'resize', onWindowResize, false );
				container.appendChild( renderer.domElement );
				
				// Camera
						
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100);
				camera.position.set( camPosition.x, camPosition.y, camPosition.z );				
				camera.lookAt(cameraLookAt);
				camera.updateMatrixWorld();	
				
				scene.add( camera );

				createObjects();

				// interaction

				container.addEventListener( 'mousedown', onMouse, false );
				container.addEventListener( 'mousemove', onMouse, false );
				container.addEventListener( 'mouseup', onMouse, false );
				container.addEventListener( 'wheel', onWheel, false );
				container.addEventListener( 'touchstart', onTouch, false );
				container.addEventListener( 'touchend', onTouch, false );
				container.addEventListener( 'touchmove', onTouch, false );			
			}

			// create objects  -----------------------------------------------------------

			function createObjects() {
                
                let pos = new THREE.Vector3(0.0, (numObjects * objectsSize.y + lastObjectsSize.y) * 1.4 + 0.2, 0.0);
				let pose = new Pose();
				let lastBody = null;
				let jointPose0 = new Pose();
				let jointPose1 = new Pose();
				let lastSize = objectsSize.clone();
								
				for (let i = 0; i < numObjects; i++) {                

					let size = i < numObjects - 1 ? objectsSize : lastObjectsSize;

					// graphics

					let boxVis = new THREE.Mesh(new THREE.BoxBufferGeometry(), new THREE.MeshPhongMaterial({color: 0xf78a1d}));
					boxVis.scale.set(size.x, size.y, size.z);
					boxVis.name = "box " + i;
					boxVis.layers.enable(1);
					boxVis.castShadow = true;
					boxVis.receiveShadow = true;

					scene.add(boxVis);

					// physics

					pose.p.set(pos.x, pos.y - i * objectsSize.y, pos.z);

					let boxBody = new Body(pose, boxVis);
					boxBody.setBox(size);
					bodies.push(boxBody);
										
					let s = i % 2 == 0 ? -0.5 : 0.5;
					jointPose0.p.set(s * size.x, 0.5 * size.y, s * size.z);
					jointPose1.p.set( s * lastSize.x, -0.5 * lastSize.y, s * lastSize.z);

					if (!lastBody) {
						jointPose1.copy(jointPose0);
						jointPose1.p.add(pose.p);
					}

					let joint = new Joint(boxBody, lastBody, jointPose0, jointPose1);
					joint.rotDamping = rotDamping;
					joint.transDamping = transDamping;
					joints.push(joint);
					
					lastBody = boxBody;
					lastSize.copy(size);
				}
			}	

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			// Pose  -----------------------------------------------------------

			class Pose {
				constructor() {
					this.p = new THREE.Vector3(0.0, 0.0, 0.0);
					this.q = new THREE.Quaternion(0.0, 0.0, 0.0, 1.0);					
				}
				transform(v) {
					v.applyQuaternion(this.q);
					v.add(this.p);
				}
				rotate(v) {
					v.applyQuaternion(this.q);
				}
				invTransform(v) {
					v.sub(this.p);
					v.applyQuaternion(this.q.conjugate());
				}
				rotateInv(v) {
					v.applyQuaternion(this.q.conjugate());
				}
				transform(pose) {
					this.q.multiply(pose.q);
					this.rotate(pose.p);
					pose.p.add(this.p);
				}
				copy(pose) {
					this.p.copy(pose.p);
					this.q.copy(pose.q);
				}
				clone() {
					var newPose = new Pose();
					newPose.p = this.p.clone();
					newPose.q = this.q.clone();
					return newPose;
				}
			}

			// Rigid body class  -----------------------------------------------------------

			class Body {
				constructor(pose, mesh) 
				{ 
					this.pose = pose.clone();
					this.prevPose = pose.clone();
					this.origPose = pose.clone();
					this.vel = new THREE.Vector3(0.0, 0.0, 0.0);
					this.omega = new THREE.Vector3(0.0, 0.0, 0.0);
					
					this.invMass = 1.0;
					this.invInertia = new THREE.Vector3(1.0, 1.0, 1.0);
					this.mesh = mesh;
					this.mesh.position.copy(this.pose.p);
					this.mesh.quaternion.copy(this.pose.q);
					mesh.userData.physicsBody = this;
				}

				setBox(size, density = 1.0) {
					let mass = size.x * size.y * size.z * density;
					this.invMass = 1.0 / mass;
					mass /= 12.0;
					this.invInertia.set(
						1.0 / (size.y * size.y + size.z * size.z) / mass,
						1.0 / (size.z * size.z + size.x * size.x) / mass,
						1.0 / (size.x * size.x + size.y * size.y) / mass);
				}

				applyRotation(rot, scale = 1.0) {

					let maxPhi = 0.5;
					let phi = rot.length();
					if (Math.abs(phi) * scale > maxPhi) 		// safety
						scale = maxPhi / phi;
						
					let dq = new THREE.Quaternion(rot.x * scale, rot.y * scale, rot.z * scale, 0.0);					
					dq.multiply(this.pose.q);
					this.pose.q.set(this.pose.q.x + 0.5 * dq.x, this.pose.q.y + 0.5 * dq.y, 
							this.pose.q.z + 0.5 * dq.z, this.pose.q.w + 0.5 * dq.w);
					this.pose.q.normalize();
				}

				integrate(dt) {
					this.prevPose.copy(this.pose);
					this.vel.addScaledVector(gravity, dt);					
					this.pose.p.addScaledVector(this.vel, dt);
					this.applyRotation(this.omega, dt);
				}

				update(dt) {
					this.vel.subVectors(this.pose.p, this.prevPose.p);
					this.vel.multiplyScalar(1.0 / dt);
					let dq = new THREE.Quaternion();
					dq.multiplyQuaternions(this.pose.q, this.prevPose.q.conjugate());
					this.omega.set(dq.x * 2.0 / dt, dq.y * 2.0 / dt, dq.z * 2.0 / dt);
					if (dq.w < 0.0)
						this.omega.set(-this.omega.x, -this.omega.y, -this.omega.z);

					this.mesh.position.copy(this.pose.p);
					this.mesh.quaternion.copy(this.pose.q);
				}

				getVelocityAt(pos) {					
					let vel = new THREE.Vector3(0.0, 0.0, 0.0);					
					vel.subVectors(pos, this.pose.p);
					vel.cross(this.omega);
					vel.subVectors(this.vel, vel);
					return vel;
				}

				getInverseMass(normal, pos = null) {
					let n = new THREE.Vector3();
					if (pos === null) 
						n.copy(normal);
					else {
						n.subVectors(pos, this.pose.p);
						n.cross(normal);
					}
					this.pose.rotateInv(n);
					let w = 
						n.x * n.x * this.invInertia.x +
						n.y * n.y * this.invInertia.y +
						n.z * n.z * this.invInertia.z;
					if (pos !== null)
						w += this.invMass;
					return w;
				}

				applyCorrection(corr, pos = null, velocityLevel = false) {
					let dq = new THREE.Vector3();
					if (pos === null) 
						dq.copy(corr);
					else {
						if (velocityLevel)
							this.vel.addScaledVector(corr, this.invMass);
						else
							this.pose.p.addScaledVector(corr, this.invMass);
						dq.subVectors(pos, this.pose.p);
						dq.cross(corr);
					}
					this.pose.rotateInv(dq);
					dq.set(this.invInertia.x * dq.x, 
						this.invInertia.y * dq.y, this.invInertia.z * dq.z);
					this.pose.rotate(dq);
					if (velocityLevel)
						this.omega.add(dq);
					else 
						this.applyRotation(dq);
				}
			}

			function applyBodyPairCorrection(body0, body1, corr, compliance, dt, pos0 = null, pos1 = null, 
				velocityLevel = false) 
			{
				let C = corr.length();
				if ( C == 0.0)
					return;

				let normal = new THREE.Vector3();
				normal.copy(corr);
				normal.normalize();

				let w0 = body0 ? body0.getInverseMass(normal, pos0) : 0.0;
				let w1 = body1 ? body1.getInverseMass(normal, pos1) : 0.0;

				let w = w0 + w1;
				if (w == 0.0)
					return;

				let lambda = -C / (w + compliance / dt / dt);
				normal.multiplyScalar(-lambda);
				if (body0)
					body0.applyCorrection(normal, pos0, velocityLevel);
				if (body1) {
					normal.multiplyScalar(-1.0);
					body1.applyCorrection(normal, pos1, velocityLevel);
				}
			}

			// Joint class  -----------------------------------------------------------

			class Joint {
				constructor(body0, body1, localPose0, localPose1) 
				{ 
					this.body0 = body0;
					this.body1 = body1;
					this.localPose0 = localPose0.clone();
					this.localPose1 = localPose1.clone();
					this.globalPose0 = localPose0.clone();
					this.globalPose1 = localPose1.clone();
					this.corr = new THREE.Vector3(0.0, 0.0, 0.0);
					this.compliance = 0.0;
					this.rotDamping = 0.0;
					this.transDamping = 0.0;
				}

				updateGlobalPoses() {
					this.globalPose0.copy(this.localPose0);
					if (this.body0)
						this.body0.pose.transform(this.globalPose0);
					this.globalPose1.copy(this.localPose1);
					if (this.body1)
						this.body1.pose.transform(this.globalPose1);
				}

				solvePos(dt) {
					this.updateGlobalPoses();

					// simple attachment
					this.corr.subVectors(this.globalPose1.p, this.globalPose0.p);
					applyBodyPairCorrection(this.body0, this.body1, this.corr, this.compliance, dt,
						this.globalPose0.p, this.globalPose1.p);
				}

				solveVel(dt) { 
					if (this.rotDamping > 0.0) {
						let omega = new THREE.Vector3(0.0, 0.0, 0.0);
						if (this.body0)
							omega.sub(this.body0.omega);
						if (this.body1)
							omega.add(this.body1.omega); 
						omega.multiplyScalar(Math.min(1.00, this.rotDamping * dt));
						applyBodyPairCorrection(this.body0, this.body1, omega, 0.0, dt, 
								null, null, true);
					}
					if (this.transDamping > 0.0) {
						this.updateGlobalPoses();
						let vel = new THREE.Vector3(0.0, 0.0, 0.0);
						if (this.body0)
							vel.sub(this.body0.getVelocityAt(this.globalPose0.p));
						if (this.body1)
							vel.add(this.body1.getVelocityAt(this.globalPose1.p));
						vel.multiplyScalar(Math.min(1.0, this.transDamping * dt));
						applyBodyPairCorrection(this.body0, this.body1, vel, 0.0, dt, 
								this.globalPose0.p, this.globalPose1.p, true);
					}
				}	
			}

			// Simulate -----------------------------------------------------------

			function simulate() {
				let dt = timeStep / numSubsteps;

				for (let i = 0; i < numSubsteps; i++) {
					for (let j = 0; j < bodies.length; j++) 
						bodies[j].integrate(dt);

					for (let j = 0; j < joints.length; j++)
						joints[j].solvePos(dt);

					for (let j = 0; j < bodies.length; j++) 
						bodies[j].update(dt);

					for (let j = 0; j < joints.length; j++)
						joints[j].solveVel(dt);
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				renderer.render( scene, camera );
				simulate();
			}			

			// scene interaction -----------------------------------------------------------

			function handleCameraMotion(dx, dy) {
				let scale = 0.01;
				let prev = camera.position.distanceTo(cameraLookAt);
				cameraDirZ.subVectors(cameraLookAt, camera.position);
				cameraDirX.set(cameraDirZ.z, 0.0, -cameraDirZ.x, 0.0);
				cameraDirX.normalize();
				cameraDirY.crossVectors(cameraDirZ, cameraDirX);
				cameraDirY.normalize();
				camera.position.addScaledVector(cameraDirX, scale * dx);
				camera.position.addScaledVector(cameraDirY, scale * dy);
				cameraDirZ.subVectors(cameraLookAt, camera.position);
				cameraDirZ.normalize();
				let delta = camera.position.distanceTo(cameraLookAt) - prev;
				camera.position.addScaledVector(cameraDirZ, -delta);
				camera.lookAt(cameraLookAt);
			}

			function handleCameraZoom(d) {
				let scale = 1.0 - 0.003 * d;
				let dist = camera.position.distanceTo(cameraLookAt);
				if (d > 0.0 && dist < 0.2 || d < 0.0 && dist > 5.0)
					return;

				camera.position.set(
					cameraLookAt.x + (camera.position.x - cameraLookAt.x) * scale,				
					cameraLookAt.y + (camera.position.y - cameraLookAt.y) * scale,				
					cameraLookAt.z + (camera.position.z - cameraLookAt.z) * scale);	
				camera.updateMatrixWorld();
			}

			function startGrab(x, y) {
				grabbedObject = null;
				mousePos.x = ( x / window.innerWidth ) * 2 - 1;
				mousePos.y = - ( y / window.innerHeight ) * 2 + 1;
				raycaster.setFromCamera( mousePos, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				if (intersects.length > 0) {
					let body = grabbedBody = intersects[0].object.userData.physicsBody;	
					grabDistance = intersects[0].distance;
					let pose0 = new Transform();
					let pose1 = new Transform();

					let hit = raycaster.ray.origin.clone();
					hit.addScaledVector(raycaster.ray.direction, grabDistance);
					pose1.p.copy(hit);
					body.pose.invTransform(hit);
					pose0.p.copy(hit);					
					grabJoint = new Joint(body, null, pose0, pose1);
					joints.push(grabJoint);
				}
			}

			function moveGrabbed(x, y) {
				if (!grabJoint)
					return;					

				mousePos.x = ( x / window.innerWidth ) * 2 - 1;
				mousePos.y = - ( y / window.innerHeight ) * 2 + 1;
				raycaster.setFromCamera( mousePos, camera );
				grabJoint.pose1.p.copy(raycaster.ray.origin);
				grabJoint.pose1.p.addScaledVector(raycaster.ray.direction, grabDistance);
			}

			function endGrab() {
				if (grabJoint) {
					joints.pop();
					grabJoint = null;
				}
			}
						
			
			function onMouse( evt ) 
			{
				event.preventDefault();
				if (evt.type == "mousedown") {
					startGrab(evt.clientX, evt.clientY);
					mouseDown = true;
				}
				else if (evt.type == "mousemove" && mouseDown) {
					if (grabbedObject)
						moveGrabbed(evt.clientX, evt.clientY);
					else
						handleCameraMotion(evt.movementX, evt.movementY);
				}
				else if (evt.type == "mouseup" || evt.type == "mouseout") {
					mouseDown = false;
					endGrab();
				}
			}

			function onWheel( evt ) 
			{
				handleCameraZoom(-evt.deltaY * 0.1 );
			}

			var touchCoords = [ { x : 0.0, y : 0.0}, { x : 0.0, y : 0.0}];

			function onTouch( evt ) {
				event.preventDefault();

				if (evt.type == "touchdown") {
					if (evt.touches.length == 1)
						startGrab(evt.touches[0].clientX, evt.touches[0].clientY);
				}

				if (evt.type == "touchmove") {
					if (grabbedObject) {
						moveGrabbed(evt.touches[0].clientX, evt.touches[0].clientY);
					}
					else {
						if (evt.touches.length == 1) {
							handleCameraMotion(
								evt.touches[0].clientX - touchCoords[0].x,
								evt.touches[0].clientY - touchCoords[0].y);
						}
						else if (evt.touches.length == 2) {
							let px = (touchCoords[1].x - touchCoords[0].x);
							let py = (touchCoords[1].y - touchCoords[0].y);
							let p = Math.sqrt(px * px + py * py);
							let dx = (evt.touches[1].clientX - evt.touches[0].clientX);
							let dy = (evt.touches[1].clientY - evt.touches[0].clientY);
							let d = Math.sqrt(dx * dx + dy * dy);
							handleCameraZoom(d - p);
						}
					}
				}
				else if (evt.type == "touchup") {
					if (evt.touches.length == 0)
						endGrab();
				}
				if (evt.touches.length <= 2) {
					for (let i = 0; i < evt.touches.length; i++) {
						touchCoords[i].x = evt.touches[i].clientX;
						touchCoords[i].y = evt.touches[i].clientY;
					}
				}				
			}

			init();
			animate();											

		</script>

	</body>
</html>